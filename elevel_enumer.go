// Code generated by "enumer -type=ELevel -json"; DO NOT EDIT.

package main

import (
	"encoding/json"
	"fmt"
)

const _ELevelName = "OCRPROOF_READ"

var _ELevelIndex = [...]uint8{0, 3, 13}

func (i ELevel) String() string {
	if i < 0 || i >= ELevel(len(_ELevelIndex)-1) {
		return fmt.Sprintf("ELevel(%d)", i)
	}
	return _ELevelName[_ELevelIndex[i]:_ELevelIndex[i+1]]
}

var _ELevelValues = []ELevel{0, 1}

var _ELevelNameToValueMap = map[string]ELevel{
	_ELevelName[0:3]:  0,
	_ELevelName[3:13]: 1,
}

// ELevelString retrieves an enum value from the enum constants string name.
// Throws an error if the param is not part of the enum.
func ELevelString(s string) (ELevel, error) {
	if val, ok := _ELevelNameToValueMap[s]; ok {
		return val, nil
	}
	return 0, fmt.Errorf("%s does not belong to ELevel values", s)
}

// ELevelValues returns all values of the enum
func ELevelValues() []ELevel {
	return _ELevelValues
}

// IsAELevel returns "true" if the value is listed in the enum definition. "false" otherwise
func (i ELevel) IsAELevel() bool {
	for _, v := range _ELevelValues {
		if i == v {
			return true
		}
	}
	return false
}

// MarshalJSON implements the json.Marshaler interface for ELevel
func (i ELevel) MarshalJSON() ([]byte, error) {
	return json.Marshal(i.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for ELevel
func (i *ELevel) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("ELevel should be a string, got %s", data)
	}

	var err error
	*i, err = ELevelString(s)
	return err
}
