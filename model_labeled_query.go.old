package main

type LabeledQuery struct {
	Words   []string
	ELevels []ELevel
	Tags    []string
}

func NewLabeledQuery(s string) *LabeledQuery {
	var (
		orig    = []rune(s)
		word    = []rune{}
		key     = ""
		words   = []string{}
		elevels = []ELevel{}
		tags    = []string{}

		isInWord  int  = 0 // 0: no; 1: word; 2: phrase
		isEscaped bool = false
	)

	for i, r := range orig {
		if isEscaped {
			word = append(word, r)
			isEscaped = false
		} else {
			switch r {
			case ' ':
				if isInWord == 1 {
					switch key {
					case "elevel":
						el, _ := ELevelString(string(word))
						elevels = append(elevels, el)
					case "tag":
						tags = append(tags, string(word))
					default:
						words = append(words, string(word))
					}
					isInWord = 0
					key = ""
				} else {
					word = append(word, r)
				}
			case '"':
				if isInWord == 0 {
					word = []rune{}
					isInWord = 2
				} else if isInWord == 1 {
					word = append(word, '\\', r)
				} else {
					if len(orig) == i+1 || orig[i+1] == ' ' {
						switch key {
						case "elevel":
							el, _ := ELevelString(string(word))
							elevels = append(elevels, el)
						case "tag":
							tags = append(tags, string(word))
						default:
							words = append(words, string(word))
						}
						isInWord = 0
						key = ""
					} else {
						word = append(word, '\\', r)
					}
				}
			case ':':
				if isInWord == 1 {
					key = string(word)
					word = []rune{}
				}
			default:
				if isInWord == 0 {
					word = []rune{r}
					isInWord = 1
				} else {
					word = append(word, r)
				}
			}
		}
	}
	if isInWord != 0 {
		switch key {
		case "elevel":
			el, _ := ELevelString(string(word))
			elevels = append(elevels, el)
		case "tag":
			tags = append(tags, string(word))
		default:
			words = append(words, string(word))
		}
		isInWord = 0
		key = ""
	}
	return &LabeledQuery{
		Words:   words,
		ELevels: elevels,
		Tags:    tags,
	}
}
